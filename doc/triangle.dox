namespace Magnum {
/** @page examples-triangle Your first triangle
@brief Creating OpenGL context and basic rendering.

- Next example: @ref examples-textured-triangle

@image html triangle/triangle.png
@image latex triangle/triangle.png

@tableofcontents

@section examples-triangle-context Setting up, preparing the mesh and shader

For this example we will use GLUT toolkit, which is implemented in
Platform::GlutApplication class. We subclass it and next to the constructor we
implement two required functions, one which is called after the window is
resized and one for rendering into the window. We also need mesh encapsulating
our triangle, buffer to store vertex data and shader (created below) which
will take care of rendering.
@dontinclude triangle/TriangleExample.h
@skip class TriangleExample
@until };

In the constructor we pass necessary arguments to
@ref Platform::GlutApplication "GlutApplication" class.
@dontinclude triangle/TriangleExample.cpp
@skipline TriangleExample::TriangleExample

Now we specify vertex attributes, consisting of positions and colors. For
performance reasons it is common to interleave them, so data for each vertex
are in one continuous place in memory. We will cheat a bit here and use
three-component vectors for both 2D positions and colors (homogeneous 2D
coordinates and RGB values), so we can interleave them in place. In next
tutorial we will learn how to interleave them programatically.
@skip data
@until };

We then create vertex buffer and fill it with the data. The data won't be
changed or read back into memory during application lifetime, so we mark them
with appropriate @ref Buffer::Usage "buffer usage".
@skip Buffer
@until setData

Now we configure the mesh - we specify @ref Mesh::Primitive "mesh primitive"
and vertex count, add vertex buffer and specify attribute locations for use
with our shader. We specify our attributes in the same order as physical
location of vertex attributes in the buffer - zero offset from the beginning,
first position, then color. Vertex attribute definitions are in
`TriangleShader` class, which will be explained later.
@skip mesh.
@until }

Function `viewportEvent()` just passes current window size to the framebuffer,
so the triangle is rendered at proper size and position.
@skip TriangleExample::viewportEvent
@until }
@until }

Function `drawEvent()` will take care about drawing the scene. We clear color
buffer, tell that the drawing is done using our shader and then we draw the
mesh. The context is double buffered, so we need to swap the buffers after
drawing.
@skip TriangleExample::drawEvent
@until }

 - @ref triangle/TriangleExample.h
 - @ref triangle/TriangleExample.cpp

@section examples-triangle-shader Triangle shader

Our shader is pretty simple - it takes only vertex position and color and
doesn't need any uniform to operate. We define both attributes as @ref Vector3
(the same type we used for the mesh data earlier) and assign vertex position
to location zero and color to one:
@dontinclude triangle/TriangleShader.h
@skip class TriangleShader
@until };

In the constructor we load GLSL sources for fragment and vertex shader, attach
them to shader program and link the program together:
@dontinclude triangle/TriangleShader.cpp
@skip TriangleShader::TriangleShader
@until }

 - @ref triangle/TriangleShader.h
 - @ref triangle/TriangleShader.cpp
 - @ref triangle/TriangleShader.vert
 - @ref triangle/TriangleShader.frag

@section examples-triangle-compilation Compilation

Now we can compile the whole example using CMake. First we find required
%Magnum package with GlutApplication library and add its include dir.

@dontinclude triangle/CMakeLists.txt
@skip find_package
@until include_directories

Then we collect our source files, create our executable and link to %Magnum
libraries.

@skip add_executable
@until MAGNUM_GLUTAPPLICATION_LIBRARIES})

- @ref triangle/CMakeLists.txt

- Next example: @ref examples-textured-triangle

*/
}
